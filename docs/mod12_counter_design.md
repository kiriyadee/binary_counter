// This document provides a comprehensive guide on designing a Mod-12 Synchronous Counter using JK Flip-Flops.
// It includes the following sections:
// 1. Basic Requirements: Defines the Mod-12 Counter and calculates the number of Flip-Flops needed.
// 2. State Diagram: Illustrates the state transitions of the counter.
// 3. State Table: Details the state transitions and JK input conditions.
// 4. Boolean Functions: Derives the Boolean functions for each Flip-Flop.
// 5. Logic Circuit: Describes the components and connections required for the counter.
// 6. Additional Considerations: Discusses the advantages of using a Synchronous Counter and reset conditions.
// 7. Testing: Outlines the steps to test the counter's functionality.
// 8. Advantages of Mod-12 Counter: Highlights the benefits and applications of the counter.
// 9. LCD Display: Explains how to display the counter's state on an LCD using a microcontroller.
// 10. Tinkercad Simulation: Provides a step-by-step guide to simulate the counter in Tinkercad.
// 11. Exercises and Review Questions: Includes questions to reinforce understanding of the counter design.
// Summary: Summarizes the design process and the educational value of using Tinkercad for circuit design.

# การออกแบบ Mod-12 Synchronous Counter ด้วย JK Flip-Flops

## 1. ความต้องการพื้นฐาน

### 1.1 คำนิยาม Mod-12 Counter

- เคาน์เตอร์ที่มีสถานะทั้งหมด 12 สถานะ (0 ถึง 11)
- หลังจากสถานะสุดท้าย (11) จะกลับไปที่สถานะแรก (0)

### 1.2 การคำนวณจำนวน Flip-Flops

- ใช้สูตร: \( 2^n - 1 \geq N \)
- \( N = 12 \), ดังนั้น \( 2^4 - 1 = 15 \geq 12 \)
- **ต้องใช้ Flip-Flops จำนวน 4 ตัว** (Q3, Q2, Q1, Q0)

## 2. แผนภาพสถานะ (State Diagram)

```
    0000 (0) → 0001 (1) → 0010 (2) → 0011 (3) → 0100 (4) → 0101 (5) → 0110 (6) → 0111 (7) → 1000 (8) → 1001 (9) → 1010 (10) → 1011 (11) → 0000 (0)
      ↑                                                                                                                           |
      └───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

## 2.1 การทำงานของเคาน์เตอร์

เคาน์เตอร์จะทำงานโดยการนับจากสถานะ 0000 (0) ไปจนถึงสถานะ 1011 (11) และเมื่อถึงสถานะ 1100 (12) จะรีเซ็ตกลับไปที่สถานะ 0000 (0) ตามแผนภาพสถานะที่แสดงด้านล่าง:

```
    0000 (0) → 0001 (1) → 0010 (2) → 0011 (3) → 0100 (4) → 0101 (5) → 0110 (6) → 0111 (7) → 1000 (8) → 1001 (9) → 1010 (10) → 1011 (11)
      ↑                                                                                                               |
      └───────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

## 3. ตารางการเปลี่ยนสถานะ (State Table)

### 3.1 เงื่อนไขการ Reset

- เมื่อถึงสถานะ 1100 (12) ให้กลับไปที่ 0000 (0)

### 3.2 ตาราง State Transition

| Present State |     | Next State |     | J-K Input |
| ------------- | --- | ---------- | --- | --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Q3            | Q2  | Q1         | Q0  | Clock     | Q3+ | Q2+ | Q1+ | Q0+ | J3  | K3  | J2  | K2  | J1  | K1  | J0  | K0  |
| 0             | 0   | 0          | 0   | 1         | 0   | 0   | 0   | 1   | 0   | X   | 0   | X   | 0   | X   | 1   | 0   |
| 1             | 0   | 1          | 1   | 1         | 1   | 0   | 1   | 0   | 0   | X   | 0   | X   | 1   | 0   | 0   | 1   |
| 0             | 0   | 0          | 1   | 1         | 0   | 0   | 1   | 0   | 0   | X   | 0   | X   | 1   | 0   | 0   | 1   |
| 0             | 0   | 1          | 0   | 1         | 0   | 1   | 0   | 0   | 0   | X   | 1   | 0   | 0   | X   | 0   | 1   |
| 0             | 0   | 1          | 1   | 1         | 0   | 1   | 0   | 1   | 0   | X   | 1   | 0   | 0   | X   | 1   | 0   |
| 0             | 1   | 0          | 0   | 1         | 0   | 1   | 1   | 0   | 0   | X   | 1   | 0   | 1   | 0   | 0   | 1   |
| 0             | 1   | 0          | 1   | 1         | 0   | 1   | 1   | 1   | 0   | X   | 1   | 0   | 1   | 0   | 1   | 0   |
| 0             | 1   | 1          | 0   | 1         | 1   | 0   | 0   | 0   | 1   | 0   | 0   | X   | 0   | X   | 0   | 1   |
| 0             | 1   | 1          | 1   | 1         | 1   | 0   | 0   | 1   | 1   | 0   | 0   | X   | 0   | X   | 1   | 0   |
| 1             | 0   | 0          | 0   | 1         | 1   | 0   | 1   | 0   | 1   | 0   | 0   | X   | 1   | 0   | 0   | 1   |
| 1             | 0   | 0          | 1   | 1         | 1   | 0   | 1   | 1   | 1   | 0   | 0   | X   | 1   | 0   | 1   | 0   |
| 1             | 0   | 1          | 0   | 1         | 1   | 1   | 0   | 0   | 1   | 0   | 1   | 0   | 0   | X   | 0   | 1   |

## 4. การหาฟังก์ชันบูลีน

### 4.1 สำหรับ Q0 (LSB)

- J0 = K0 = 1
- เปลี่ยนสถานะทุกครั้งที่มีนาฬิกา

### 4.2 สำหรับ Q1

- J1 = K1 = Q0'
- เปลี่ยนสถานะเมื่อ Q0 เป็น 0

### 4.3 สำหรับ Q2

- J2 = K2 = Q1 · Q0
- เปลี่ยนสถานะเมื่อทั้ง Q1 และ Q0 เป็น 1

### 4.4 สำหรับ Q3 (MSB)

- J3 = K3 = Q2 · Q1 · Q0
- เปลี่ยนสถานะเมื่อ Q2, Q1, Q0 เป็น 1

## 5. วงจรลอจิก

### 5.1 อุปกรณ์ที่ใช้

- JK Flip-Flops 4 ตัว
- เกตลอจิก AND, NOT

### 5.2 การเชื่อมต่อ

```
    Clock ─► FF0 (Q0)
    Q0    ─► FF1 (Q1)
    Q1·Q0 ─► FF2 (Q2)
    Q2·Q1·Q0 ─► FF3 (Q3)
```

**รายละเอียดการเชื่อมต่อ:**

- **การเชื่อมต่อ Clock:** สัญญาณนาฬิกาจะถูกส่งไปยังทุก Flip-Flop เพื่อให้เคาน์เตอร์เป็นแบบ Synchronous
- **การเชื่อมต่อ Outputs:** เอาต์พุตจาก Flip-Flop หนึ่งไปยังอินพุตของ Flip-Flop ถัดไปเพื่อสร้างการเปลี่ยนแปลงสถานะที่ถูกต้อง
- **เงื่อนไขการ Reset:** ใช้เกต AND และ NOT เพื่อสร้างเงื่อนไขการ Reset เมื่อถึงสถานะ 1100 (12)

## 6. ข้อพิจารณาเพิ่มเติม

### 6.1 การเลือกใช้ Synchronous Counter

การใช้ Synchronous Counter มีข้อดีเหนือกว่า Asynchronous Counter เนื่องจากทุก Flip-Flop จะได้รับสัญญาณนาฬิกาเดียวกัน จึงลดปัญหาการหน่วงเวลา (Propagation Delay) และทำให้การเปลี่ยนสถานะมีความแม่นยำและเสถียรขึ้น

### 6.2 การจัดการกับการรีเซ็ต

การรีเซ็ตเมื่อถึงสถานะ 12 เป็นสิ่งสำคัญในการรักษาการนับให้ถูกต้อง ดังนั้น การออกแบบวงจรรีเซ็ตต้องมั่นใจว่าเกิดขึ้นทันทีที่เคาน์เตอร์ถึงสถานะที่ต้องการ

## 7. การทดสอบ

การทดสอบเป็นขั้นตอนสำคัญในการตรวจสอบความถูกต้องของการออกแบบเคาน์เตอร์ เพื่อให้แน่ใจว่าทำงานได้ตามที่กำหนด

### 7.1 การนับ

ตรวจสอบการนับจากสถานะเริ่มต้น 0000 (0) ถึงสถานะสุดท้าย 1011 (11) ว่าเคาน์เตอร์เปลี่ยนสถานะตามที่กำหนดหรือไม่

### 7.2 การรีเซ็ต

ตรวจสอบว่าเมื่อเคาน์เตอร์ถึงสถานะ 1100 (12) จะรีเซ็ตกลับไปที่สถานะ 0000 (0) อย่างถูกต้อง

### 7.3 ความถูกต้องของสัญญาณนาฬิกา

วัดความถูกต้องของสัญญาณนาฬิกาเพื่อให้มั่นใจว่าเคาน์เตอร์ทำงานตามจังหวะที่ถูกต้อง

### 7.4 ความถูกต้องของ Flip-Flops

ตรวจสอบว่าแต่ละ Flip-Flop ทำงานได้ถูกต้องและไม่มีข้อผิดพลาดในการเปลี่ยนสถานะ

## 8. ข้อดีของ Mod-12 Counter

- **การใช้งานที่หลากหลาย:** เหมาะสำหรับระบบที่ต้องการนับรอบเวลา 12 ชั่วโมง หรือนาฬิกาดิจิทัล
- **ความเสถียรและแม่นยำ:** การออกแบบแบบ Synchronous Counter ทำให้มีความเสถียรและแม่นยำสูงในการนับ
- **การขยายตัวง่าย:** สามารถนำไปประยุกต์ใช้ในระบบอื่นๆ ที่ต้องการการนับแบบวนรอบ

## 9. การแสดงผลบนจอ LCD

การแสดงผลสถานะของเคาน์เตอร์บนจอ LCD ช่วยให้ผู้ใช้สามารถดูการนับแบบเรียลไทม์ได้อย่างชัดเจน

### 9.1 การเชื่อมต่อกับไมโครคอนโทรลเลอร์

- เชื่อมต่อขาเอาต์พุตของเคาน์เตอร์ (Q3, Q2, Q1, Q0) กับขาอินพุตของไมโครคอนโทรลเลอร์
- ใช้พอร์ต I/O ของไมโครคอนโทรลเลอร์ในการอ่านสถานะของเคาน์เตอร���

### 9.2 การเขียนโปรแกรม

- เขียนโปรแกรมในไมโครคอนโทรลเลอร์เพื่อแปลงสถานะของเคาน์เตอร์เป็นค่าเลขทศนิยม
- ส่งข้อมูลไปยังจอ LCD เพื่อแสดงผลรหัสเลขที่นับได้ปัจจุบัน

### 9.3 การตรวจสอบการแสดงผล

- ตรวจสอบว่าการแสดงผลบนจอ LCD ตรงกับสถานะของเคาน์เตอร์ทุกครั้งที่มีการเปลี่ยนสถานะ
- ตรวจสอบการรีเซ็ตและการเริ่มนับใหม่บนจอ LCD ให้ถูกต้อง

## 10. การสร้างวงจรใน Tinkercad

### 10.1 ขั้นตอนการสร้างวงจร

1. เปิดเว็บไซต์ [Tinkercad](https://www.tinkercad.com/)
2. สร้างโปรเจกต์ใหม่และเลือก "วงจร" (Circuits)
3. เพิ่ม JK Flip-Flops จำนวน 4 ตัวลงในพื้นที่ทำงาน
4. เชื่อมต่อขา Clock ของทุก Flip-Flop เข้ากับสัญญาณนาฬิกาเดียวกัน
5. เชื่อมต่อขา Q0 ของ FF0 เข้ากับขา J1 และ K1 ของ FF1
6. เชื่อมต่อขา Q1 และ Q0 ของ FF1 และ FF0 เข้ากับขา J2 และ K2 ของ FF2
7. เชื่อมต่อขา Q2, Q1 และ Q0 ของ FF2, FF1 และ FF0 เข้ากับขา J3 และ K3 ของ FF3
8. เพิ่มเกต AND และ NOT เพื่อสร้างเงื่อนไขการ Reset เมื่อถึงสถานะ 1100 (12)
9. เชื่อมต่อขาเอาต์พุตของเคาน์เตอร์กับขาอินพุตของไมโครคอนโทรลเลอร์
10. เขียนโปรแกรมในไมโครคอนโทรลเลอร์เพื่อแสดงผลสถานะของเคาน์เตอร์บนจอ LCD

### 10.2 การทดสอบวงจรใน Tinkercad

1. เริ่มการจำลอง (Simulation) ใน Tinkercad
2. ตรวจสอบการนับจาก 0000 (0) ถึง 1011 (11)
3. ตรวจสอบการ Reset กลับไปที่ 0000
4. ตรวจสอบการแสดงผลบนจอ LCD ให้ตรงกับสถานะของเคาน์เตอร์

## e) การจำลองวงจรที่ออกแบบในโปรแกรม TinkerCAD

### ขั้นตอนการจำลอง

1. **เข้าใช้งาน TinkerCAD:**

   - เปิดเว็บไซต์ [Tinkercad](https://www.tinkercad.com/) และเข้าสู่ระบบ

2. **สร้างโปรเจกต์ใหม่:**

   - เลือก "วงจร" (Circuits) และสร้างโปรเจกต์ใหม่

3. **เพิ่มอุปกรณ์:**

   - เพิ่ม JK Flip-Flops จำนวน 4 ตัว
   - เพิ่มเกต AND และ NOT ตามความต้องการ

4. **เชื่อมต่อวงจร:**

   - เชื่อมต่อสัญญาณนาฬิกา (Clock) ไปยังทุก Flip-Flop
   - เชื่อมต่อ Q0 จาก FF0 ไปยัง J1 และ K1 ของ FF1 ผ่าน NOT gate
   - เชื่อมต่อ Q1 และ Q0 จาก FF1 และ FF0 ไปยัง J2 และ K2 ของ FF2 ผ่าน AND gate
   - เชื่อมต่อ Q2, Q1, Q0 จาก FF2, FF1, FF0 ไปยัง J3 และ K3 ของ FF3 ผ่าน AND gate
   - เชื่อมต่อเงื่อนไขการ Reset จาก AND gate เมื่อถึงสถานะ 1100 (12) ให้รีเซ็ตกลับไปที่ FF0 - FF3

5. **เชื่อมต่อกับไมโครคอนโทรลเลอร์และจอ LCD:**

   - เชื่อมต่อขาเอาต์พุตจาก Flip-Flop กับพอร์ต I/O ของไมโครคอนโทรลเลอร์
   - เชื่อมต่อจอ LCD เข้ากับไมโครคอนโทรลเลอร์

6. **เขียนโปรแกรม:**

   - เขียนโค้ดในไมโครคอนโทรลเลอร์เพื่ออ่านสถานะของ Flip-Flops และแสดงผลบนจอ LCD

7. **เริ่มการจำลอง:**

   - คลิก "Start Simulation" ใน Tinkercad และตรวจสอบการทำงานของเคาน์เตอร์
   - ตรวจสอบการนับจาก 0000 ถึง 1011 และการรีเซ็ตกลับไปที่ 0000

8. **ตรวจสอบการแสดงผล:**
   - ตรวจสอบว่าจอ LCD แสดงเลขที่ถูกต้องตามสถานะของเคาน์เตอร์ทุกครั้งที่มีการเปลี่ยนแปลง

### การทดสอบการจำลอง

- **การนับ:** ตรวจสอบว่านาฬิกาเพิ่มจำนวนทุกนาที ตัวเลขในจอ LCD เปลี่ยนจาก 0 ถึง 11 อย่างถูกต้อง
- **การรีเซ็ต:** เมื่อเคาน์เตอร์ถึง 12 (1100) ระบบควรรีเซ็ตกลับไปที่ 0 และเริ่มนับใหม่
- **ความถูกต้องของสัญญาณนาฬิกา:** ตรวจสอบความสม่ำเสมอของสัญญาณนาฬิกาเพื่อให้การนับเป็นไปตามที่กำหนด
- **การแสดงผล:** เลขที่แสดงบนจอ LCD ควรตรงกับสถานะของเคาน์เตอร์ทุกครั้งที่มีการเปลี่ยนแปลง

### 11. แบบฝึกหัดและคำถามเพื่อการทบทวน

1. อธิบายความแตกต่างระหว่าง Synchronous Counter และ Asynchronous Counter
2. หากต้องการสร้างเคาน์เตอร์แบบ Mod-16 จำนวน Flip-Flopsที่ต้องใช้เป็นเท่าไร และเพราะเหตุใด?
3. อธิบายกระบวนการหาฟังก์ชันบูลีนสำหรับ Flip-Flop แต่ละตัว
4. อะไรคือข้อดีของการใช้ Tinkercad ในการออกแบบและทดสอบวงจรอิเล็กทรอนิกส์?
5. สร้างแผนภาพสถานะเพิ่มเติมสำหรับเคาน์เตอร์ที่นับถึง 15 (Mod-16) และเปรียบเทียบกับ Mod-12

## สรุป

การออกแบบ Mod-12 Synchronous Counter ด้วย JK Flip-Flops เป็นกระบวนการที่ต้องอาศัยความเข้าใจในหลักการทำงานของ Flip-Flops การหาฟังก์ชันบูลีน การออกแบบวงจรลอจิก และการทดสอบอย่างละเอียด การใช้เครื่องมือเช่น Tinkercad ช่วยให้นักศึกษาได้ทดลองและเรียนรู้การออกแบบวงจรจริงได้อย่างมีประสิทธิภาพ เอกสารนี้หวังว่าจะเป็นประโยชน์ในการศึกษาด้านอิเล็กทรอนิกส์ดิจิทัลและการออกแบบระบบนับที่ซับซ้อนสำหรับนักศึกษา

## 4.5 แผนภาพ K-Map สำหรับการหาฟังก์ชันบูลีน

### K-Map สำหรับ Q0

| Q1Q0\Q3Q2 | 00  | 01  | 11  | 10  |
| --------- | --- | --- | --- | --- |
| 00        | 0   | 1   | 0   | 1   |
| 01        | 1   | 0   | 1   | 0   |
| 11        | 0   | 1   | 0   | 1   |
| 10        | 1   | 0   | 1   | 0   |

### K-Map สำหรับ Q1

| Q1Q0\Q3Q2 | 00  | 01  | 11  | 10  |
| --------- | --- | --- | --- | --- |
| 00        | 0   | 0   | 0   | 0   |
| 01        | 1   | 1   | 1   | 1   |
| 11        | 0   | 0   | 0   | 0   |
| 10        | 1   | 1   | 1   | 1   |

### K-Map สำหรับ Q2

| Q1Q0\Q3Q2 | 00  | 01  | 11  | 10  |
| --------- | --- | --- | --- | --- |
| 00        | 0   | 0   | 0   | 0   |
| 01        | 0   | 0   | 0   | 0   |
| 11        | 1   | 1   | 1   | 1   |
| 10        | 1   | 1   | 1   | 1   |

### K-Map สำหรับ Q3

| Q1Q0\Q3Q2 | 00  | 01  | 11  | 10  |
| --------- | --- | --- | --- | --- |
| 00        | 0   | 0   | 0   | 0   |
| 01        | 0   | 0   | 0   | 0   |
| 11        | 0   | 0   | 0   | 0   |
| 10        | 1   | 1   | 1   | 1   |

จากแผนภาพ K-Map ข้างต้น เราสามารถหาฟังก์ชันบูลีนสำหรับแต่ละ Q ได้ดังนี้:

การออกแบบตัวนับแบบโมดูลัส 12 (Mod-12 Counter) ที่อธิบายการเปลี่ยนแปลงของบิตแต่ละตัว (Q0, Q1, Q2, Q3) ในรูปแบบที่เข้าใจง่ายขึ้น:

Q0: เปลี่ยนสถานะทุกครั้งที่มีการนับ (Toggle ทุกครั้ง)
Q1: เปลี่ยนสถานะเมื่อ Q0 เปลี่ยนจาก 1 เป็น 0 (Toggle เมื่อ Q0 = 1)
Q2: เปลี่ยนสถานะเมื่อ Q1 และ Q0 เป็น 1 (Toggle เมื่อ Q1 และ Q0 = 1)
Q3: เปลี่ยนสถานะเมื่อ Q2, Q1 และ Q0 เป็น 1 (Toggle เมื่อ Q2, Q1 และ Q0 = 1)
